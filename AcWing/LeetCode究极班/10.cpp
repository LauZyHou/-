class Solution {
public:
    bool isMatch(string s, string p) {
        // f[i][j]，集合：所有s[1~i]和p[1~j]的匹配方案
        // 属性：bool，是否存在一个合法方案
        
        // 状态计算：
        // p[j]不是'*'：看s[i]==p[j]或者p[j]是'.'，然后前面的部分也匹配f[i-1][j-1]
        // p[j]是'*'：看'*'表示多少个字符
        // 0个字符：f[i][j-2]
        // 1个字符：f[i-1][j-2]并且s[i]要匹配p[j-1]（指和p[j-1]一样或者p[j-1]是'.'）
        // 2个字符：f[i-2][j-2]并且s[i]、s[i-1]要一样且匹配p[j-1]
        // 继续枚举..

        // 优化，因为f[i][j]在p[j]!='*'时是：
        // f[i][j-2] | f[i-1][j-2] & s[i] == p[j-1] | f[i-2][j-2] & s[i] == p[j-1] & s[i-1] == p[j-1] | ...
        // 而f[i-1][j]在p[j]!='*'时时：
        //             f[i-1][j-2]                  | f[i-2][j-2]                  & s[i-1] == p[j-1] | ...
        // 从而后面的部分，就是f[i-1][j] && s[i] 匹配 p[j-1]就行了，这样就省去了枚举的代价

        int n = s.size(), m = p.size();
        // 从1开始
        s = ' ' + s, p = ' ' + p;
        // dp数组
        vector<vector<bool>> f(n + 1, vector<bool>(m + 1));
        f[0][0] = true;
        // s串要从0开始，因为''是匹配'a*'的，但是模式串如果是空的就不能匹配s串，所以模式串从1开始
        for (int i = 0; i <= n; i ++) {
            for (int j = 1; j <= m; j ++) {
                // 特判一下p串下一个字符是'*'的状态，"a*"这里的'a'不能用
                if (j + 1 <= m && p[j + 1] == '*')
                    continue;
                // p[j]不是'*'，那就要和p[j]匹配
                if (i && p[j] != '*')
                    f[i][j] = f[i - 1][j - 1] && (s[i] == p[j] || p[j] == '.');
                // p[j]是'*'，那么p[j - 1]可以重复若干次，这里用前面说的优化
                else if (p[j] == '*')
                    f[i][j] = f[i][j - 2] || i && f[i - 1][j] && (s[i] == p[j - 1] || p[j - 1] == '.'); 
            }
        }
        return f[n][m];
    }
};